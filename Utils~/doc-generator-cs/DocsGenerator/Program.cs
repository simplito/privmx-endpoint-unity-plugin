using System.Text.Json;
using System.Text.Json.Serialization;
using System.Xml;

namespace DocsGenerator;

public static class Program
{
	private static int Main(string[] args)
	{
		if (args.Length < 3 || args[0] == "--help" || args[0] == "-h")
		{
			Console.WriteLine("""
			                  Usage: ./DocsGenerator <document> <plugin> <output>
			                  
			                    document - path to xml document generated by doxygen generator
			                    plugin - path to unity plugin root
			                    output - path to json output file
			                  """);
			return 1;
		}

		var xml = File.ReadAllText(args[0]);
		var unityPluginRoot = Path.GetFullPath(args[1]);
		var manifestPath = Path.Combine(unityPluginRoot, "package.json");
		if (!File.Exists(manifestPath))
		{
			Console.WriteLine($"Failed to find manifest file at {manifestPath}");
			return 2;
		}

		var manifestContent = JsonSerializer.Deserialize<UnityManifest>(File.ReadAllText(manifestPath));
		var saveToPath = args[2];

		var doc2 = new XmlDocument();
		doc2.LoadXml(xml);

		var docs = new Docs(doc2);

		PrintDocs(docs);

		var jsonDocs = new Dictionary<string, object>
		{
			{
				"_meta", new Meta
				{
					Version = manifestContent!.Version,
					Package = "SimplitoPrivMX",
					Lang = "cs",
					Name = "PrivMX Unity Plugin"
				}
			}
		};

		foreach (var cls in docs.Classes)
		{
			var result = GetNamespaceAndClassName(cls.Name);
			if (string.IsNullOrEmpty(result.namepace))
				throw new NotImplementedException("Types without namespace are not supported");
			List<Page> pages;
			if (!jsonDocs.TryGetValue(result.namepace, out var list))
			{
				pages = new List<Page>();
				jsonDocs[result.namepace] = pages;
			}
			else if (list is List<Page>)
			{
				pages = (List<Page>)list;
			}
			else
			{
				throw new Exception("Expected list to be List<Page>, but got " + list.GetType());
			}

			var page = GetOrCreatePage(pages, result.className);
			page.Content.Add(cls);
		}

		JsonSerializerOptions options = new()
		{
			PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
			WriteIndented = true,
			DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
		};
		var json = JsonSerializer.Serialize(jsonDocs, options);
		File.WriteAllText(saveToPath, json);
		return 0;
	}

	private static Page GetOrCreatePage(List<Page> pages, string name)
	{
		Page? page = null;
		foreach (var p in pages)
			if (p.Title.Equals(name))
				page = p;
		if (page == null)
		{
			page = new Page
			{
				Title = name
			};
			pages.Add(page);
		}

		return page;
	}

	private static (string namepace, string className) GetNamespaceAndClassName(string name)
	{
		var lastDotIndex = name.LastIndexOf('.');
		if (lastDotIndex == -1)
			return (string.Empty, name);
		return (name.Substring(0, lastDotIndex), name.Substring(lastDotIndex + 1));
	}

	private static void PrintDocs(Docs docs)
	{
		foreach (var cls in docs.Classes)
		{
			Console.WriteLine("\n\n\t{0} - {1}", cls.Name, cls.Type);
			if (cls.Methods != null)
				foreach (var method in cls.Methods)
				{
					Console.WriteLine("\n\t\t\t{0} [{1}]: {2}", method.Name, method.MethodType, method.Description);
					Console.WriteLine("\t\t\t{0}", method.Snippet);
					foreach (var param in method.Params)
						Console.WriteLine("\t\t\t\t\t{0} {1} - {2}", param.Type.Name, param.Name, param.Description);
					if (method.Returns != null)
						foreach (var ret in method.Returns)
							Console.WriteLine("\t\t\t\tReturns {0} - {1}", ret.Type.Name, ret.Description);
				}

			foreach (var field in cls.Fields)
				Console.WriteLine("\n\t\t\t{0} {1} - {2}", field.Type.Name, field.Name, field.Description);
		}
	}
}